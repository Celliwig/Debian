#!/bin/bash

# Don't exit on error
#set -e

# summary of how this script can be called:
#       * <postinst> `configure' <most-recently-configured-version>
#       * <old-postinst> `abort-upgrade' <new version>
#       * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#         <new-version>
#       * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#         <failed-install-package> <version> `removing'
#         <conflicting-package> <version>
#
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package
#

. /usr/share/debconf/confmodule

# Create systemd service to autologin kiosk user
create_systemd_autologin() {
	login_username="${1}"

	systemd_service_dir="/etc/systemd/system/getty@tty1.service.d"
	systemd_service_file="${systemd_service_dir}/kiosk-user.conf"
	systemd_service="getty@tty1.service"

	# Create service directory
	if [ ! -d "${systemd_service_dir}" ]; then
		mkdir -p "${systemd_service_dir}" >/dev/null 2>&1
		if [ ${?} -ne 0 ]; then
			echo "postinst: Error creating systemd service directory"
			return 255
		fi
		db_set kiosk-user/autologin_service_dir "${systemd_service_dir}"
		db_set kiosk-user/autologin_service_dir_delete true
	else
		db_set kiosk-user/autologin_service_dir_delete false
	fi

	# Create service file
	if [ ! -f "${systemd_service_file}" ]; then
		cat > "${systemd_service_file}" << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty -o '-p -f -- \\u' --noclear --autologin ${login_username} %I $TERM
EOF

		db_set kiosk-user/autologin_service_file "${systemd_service_file}"
		db_set kiosk-user/autologin_service_file_delete true
	else
		db_set kiosk-user/autologin_service_file_delete false
	fi

	# Enable service
	systemctl enable "${systemd_service}" >/dev/null || true
	systemctl start "${systemd_service}" >/dev/null || true

	db_set kiosk-user/autologin_service_name "${systemd_service}"

	return 0
}

# Create X11 session script for startx
create_xsession() {
	xsession_file="${1}/.xinitrc"

	# Write header
	cat > "${xsession_file}" << EOF
# kiosk-user: X11 session file for startx
#
# Do not edit, use 'dpkg-reconfigure kiosk-user' to update
###########################################################

EOF

	if db_get kiosk-user/disable_blanking && [ "${RET}" = true ]; then
		cat >> "${xsession_file}" << EOF
# Disable DPMS (Energy Star) features
xset -dpms
# Disable video blanking
xset s noblank
# Disable screen saver
xset s off

EOF
	fi

	# xrandr options
	xrandr_cmd_args=""
	xrandr_reflect=""
	if db_get kiosk-user/screen_reflect_x && [ "${RET}" = true ]; then
		xrandr_reflect="${xrandr_reflect}x"
	fi
	if db_get kiosk-user/screen_reflect_y && [ "${RET}" = true ]; then
		xrandr_reflect="${xrandr_reflect}y"
	fi
	if [ -n "${xrandr_reflect}" ]; then
		xrandr_cmd_args="${xrandr_cmd_args} --reflect \"${xrandr_reflect}\""
	fi
	if db_get kiosk-user/screen_orientation_xrandr; then
		xrandr_cmd_args="${xrandr_cmd_args} --rotate \"${RET}\""
	fi
	if [ -n "${xrandr_cmd_args}" ]; then
		cat >> "${xsession_file}" << EOF
# Get Xrandr screen name
screen_name=\`tmp=\$(xrandr --query | grep -E "^.* connected [primary ]*[0-9]+x[0-9]+"); echo "\${tmp% connected*}"\`
xrandr --output "\${screen_name}" ${xrandr_cmd_args}

EOF
	fi

	# Create matchbox-window-manager args
	matchbox_wm_cmd="matchbox-window-manager"
	if db_get kiosk-user/disable_titlebar && [ "${RET}" = true ]; then
		matchbox_wm_cmd="${matchbox_wm_cmd} -use_titlebar no"
	fi
	if db_get kiosk-user/use_cursor && [ "${RET}" = true ]; then
		matchbox_wm_cmd="${matchbox_wm_cmd} -use_cursor yes"
	fi
	if db_get kiosk-user/matchbox_wm_theme; then
		matchbox_wm_cmd="${matchbox_wm_cmd} -theme ${RET}"
	fi
	cat >> "${xsession_file}" << EOF
# Start window manager
${matchbox_wm_cmd} &

EOF

	# Enable virtual keyboard
	if db_get kiosk-user/enable_virtual_keyboard && [ "${RET}" = true ]; then
		if [ -x /usr/bin/matchbox-keyboard ]; then
			cat >> "${xsession_file}" << EOF
# Enable virtual keyboard
matchbox-keyboard &

EOF
		fi
	fi

	# Hide cursor when not in use
	if db_get kiosk-user/hide_cursor && [ "${RET}" = true ]; then
		cat >> "${xsession_file}" << EOF
# Hide cursor when inactive
unclutter &

EOF
	fi

	# Run kiosk application
	if db_get kiosk-user/execpath; then
		kiosk_application="${RET}"

		kiosk_application_args=""
		if db_get kiosk-user/execargs; then
			kiosk_application_args="${RET}"
		fi

		cat >> "${xsession_file}" << EOF
# Run application
${kiosk_application} ${kiosk_application_args}
EOF
	else
		echo "postinst: No kiosk application given"
		return 255
	fi
}

# Update bash login file to include 'startx'
update_startup_script_bash() {
	login_username="${1}"

	bashrc_file="/home/${login_username}/.bashrc"
	bashrc_update=1

	# Check if file has already been updated
	if [ -f "${bashrc_file}" ]; then
		grep startx "${bashrc_file}" >/dev/null 2>&1
		if [ ${?} -eq 0 ]; then
			bashrc_update=0
		fi
	fi

	# Update bashrc
	if [ ${bashrc_update} -eq 1 ]; then
		echo "postinst: Updating .bashrc"
		cat >> "${bashrc_file}" << EOF

if [[ -z \${DISPLAY} ]] && [[ \$(tty) = /dev/tty1 ]]; then
	# Start X automatically
	startx
	# Exit shell so that systemd respawns automatic login
	exit
fi
EOF
	fi
}

# Update the correct startup script to add startx
update_startup_script() {
	login_username="${1}"

	user_data=$(getent passwd "${login_username}")
	if [ ${?} -eq 0 ]; then
		user_shell=`tmp_data=$(getent passwd "${login_username}"); basename "${tmp_data#*:/home/${login_username}:}"`

		case "${user_shell}" in
		bash)
			update_startup_script_bash "${login_username}"
			;;
		*)
			echo "postinst: unsupported shell - ${user_shell}"
			return 255
			;;
		esac
	else
		echo "postinst: Failed to get user data"
		return 255
	fi
}

# Update systemd default target
update_systemd_default_target() {
	systemd_default_target=$(systemctl get-default)

	# Save current default to use on package removal
	db_set kiosk-user/systemd_default_target_restore "${systemd_default_target}"

	# Check whether to set a new default target
	if [ ! "${systemd_default_target}" = multi-user.target ]; then
		# Set multi-user.target as systemd default
		systemctl set-default multi-user.target
	fi
}

case "$1" in
	configure)
		if db_get kiosk-user/username; then
			KIOSK_USER="$RET"
		else
			echo "postinst: Failed to get kiosk username"
			return 255
		fi

		update_systemd_default_target
		create_systemd_autologin "${KIOSK_USER}"
		create_xsession "/home/${KIOSK_USER}"
		update_startup_script "${KIOSK_USER}"
	;;
#	abort-upgrade)
#	;;
esac

exit 0
